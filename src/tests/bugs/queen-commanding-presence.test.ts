

import { GameController } from '../../controllers/GameController';
import { ZoneType } from '../../engine/models';

describe('The Queen - Commanding Presence Multi-Turn Bug', () => {
    it('should trigger "on quest" ability multiple times across turns', async () => {
        const controller = new GameController({
            onStateChange: () => { },
            onLogEntry: () => { },
        });

        // Initialize with explicit card DB and deck lists
        controller.initialize({
            player1Name: 'P1',
            player2Name: 'Bot',
            deck1Cards: ['The Queen - Commanding Presence'],
            deck2Cards: ['Target Dummy'],
            cardDatabase: [
                {
                    fullName: 'The Queen - Commanding Presence',
                    name: 'The Queen',
                    id: 'the-queen-id',
                    cost: 5,
                    ink: true,
                    type: 'Character',
                    abilities: [
                        {
                            type: 'triggered',
                            fullText: "When this character quests, you may pay 2 â¬¡ to give chosen character -4 Strength this turn."
                        }
                    ],
                    // parsedEffects will be generated by GameController.initialize -> abilitySystem.registerCard -> parseToAbilityDefinition
                },
                {
                    fullName: 'Target Dummy',
                    name: 'Target Dummy',
                    cost: 1,
                    ink: true,
                    type: 'Character',
                    strength: 4,
                    willpower: 4
                }
            ]
        });

        const p1Id = controller.getPlayerId();
        const p1 = controller['stateManager'].getPlayer(p1Id);

        // Find Queen in deck OR hand (initialize might draw cards)
        const queen = p1.deck.find(c => c.fullName === 'The Queen - Commanding Presence') ||
            p1.hand.find(c => c.fullName === 'The Queen - Commanding Presence');

        if (!queen) {
            console.log('Deck:', p1.deck.map(c => c.name));
            console.log('Hand:', p1.hand.map(c => c.name));
            throw new Error('Queen not found');
        }

        // P2 Setup
        const p2Id = controller['player2Id'];
        const p2 = controller['stateManager'].getPlayer(p2Id);
        const dummy = p2.deck[0] || p2.hand[0];

        // --- MANUAL CARD MOVEMENTS ---
        // Move Queen from wherever to Play
        if (queen.zone === ZoneType.Deck) p1.deck = p1.deck.filter(c => c !== queen);
        if (queen.zone === ZoneType.Hand) p1.hand = p1.hand.filter(c => c !== queen);
        p1.play.push(queen);
        queen.zone = ZoneType.Play;
        queen.ready = true;
        queen.turnPlayed = -1;

        // Register abilities (since we bypassed playCard)
        (controller['turnManager'] as any).abilitySystem.registerCard(queen);

        // Create Ink
        const ink1 = JSON.parse(JSON.stringify(queen));
        ink1.instanceId = 'ink1';
        ink1.zone = ZoneType.Inkwell;
        ink1.ready = true;

        const ink2 = JSON.parse(JSON.stringify(queen));
        ink2.instanceId = 'ink2';
        ink2.zone = ZoneType.Inkwell;
        ink2.ready = true;

        p1.inkwell.push(ink1, ink2);

        // Move Dummy to Play
        if (dummy.zone === ZoneType.Deck) p2.deck = p2.deck.filter(c => c !== dummy);
        if (dummy.zone === ZoneType.Hand) p2.hand = p2.hand.filter(c => c !== dummy);
        p2.play.push(dummy);
        dummy.zone = ZoneType.Play;

        // --- HIJACK CHOICE HANDLER ---
        let lastRequest: any = null;
        let pendingResolver: any = null;

        (controller['turnManager'] as any).registerChoiceHandler(p1Id, (req: any) => {
            console.log('Intercepted choice:', req.text || req.type);
            lastRequest = req;
            return new Promise(resolve => {
                pendingResolver = resolve;
            });
        });

        // FORCE START TURN
        controller['stateManager'].state.turnPlayerId = p1Id;
        controller['stateManager'].state.phase = 'Main' as any;

        // --- TURN 1 ---
        console.log('--- QUEST 1 ---');

        // 1. Quest
        const result1 = controller.quest(queen.instanceId);
        expect(result1).toBe(true);

        // 2. Wait for choice (Generic Optional)
        await new Promise(r => setTimeout(r, 10));

        if (!lastRequest) {
            console.log('FAIL: No choice even on TURN 1');
            // Debug abilities
            console.log('Queen parsedEffects:', queen.parsedEffects);
        }
        expect(lastRequest).toBeDefined();

        // Resolve YES (Generic Optional)
        const yesOption = lastRequest.options[0]; // Assuming yes is first or valid
        pendingResolver({
            requestId: lastRequest.id,
            playerId: p1Id,
            selectedIds: [yesOption.id]
        });
        lastRequest = null;

        // 2b. Wait for choice (Pay Cost?) - Double prompt due to implementation details
        await new Promise(r => setTimeout(r, 10));
        if (lastRequest && lastRequest.type === 'yes_no') {
            console.log('Resolving second prompt (Pay Cost)...');
            const yesOption2 = lastRequest.options[0];
            pendingResolver({
                requestId: lastRequest.id,
                playerId: p1Id,
                selectedIds: [yesOption2.id]
            });
            lastRequest = null;
            await new Promise(r => setTimeout(r, 10));
        }

        // 3. Wait for Target Selection
        expect(lastRequest).toBeDefined();
        expect(lastRequest.type).toContain('target');

        // Resolve Target (Dummy)
        pendingResolver({
            requestId: lastRequest.id,
            playerId: p1Id,
            selectedIds: [dummy.instanceId]
        });
        lastRequest = null;

        // Allow effect to complete
        await new Promise(r => setTimeout(r, 10));

        // --- END TURN 1 ---
        controller.endTurn();

        // Bot turn (pass)
        const tm = controller['turnManager'];
        tm.startTurn(p2Id);
        tm.passTurn(p2Id);

        // --- TURN 2 ---
        tm.startTurn(p1Id);
        expect(queen.ready).toBe(true);

        console.log('--- QUEST 2 ---');
        // Reset trap
        lastRequest = null;

        // 1. Quest
        const result2 = controller.quest(queen.instanceId);
        expect(result2).toBe(true);

        // 2. Wait for choice again
        await new Promise(r => setTimeout(r, 10));

        // EXPECTATION: Should trigger
        if (!lastRequest) {
            console.error('FAIL: Legacy bug reproduced - no choice on turn 2');
        } else {
            console.log('SUCCESS: Choice generated again!');
            // Cleanup promise so test ends cleanly
            pendingResolver({ requestId: lastRequest.id, playerId: p1Id, selectedIds: [lastRequest.options?.[0]?.id || 'cancel'] });
        }

        expect(lastRequest).toBeDefined();
    });
});
